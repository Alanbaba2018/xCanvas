!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("xCanvas",[],e):"object"==typeof exports?exports.xCanvas=e():t.xCanvas=e()}(window,function(){return function(t){var e={};function s(i){if(e[i])return e[i].exports;var n=e[i]={i:i,l:!1,exports:{}};return t[i].call(n.exports,n,n.exports,s),n.l=!0,n.exports}return s.m=t,s.c=e,s.d=function(t,e,i){s.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},s.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(s.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)s.d(i,n,function(e){return t[e]}.bind(null,n));return i},s.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(e,"a",e),e},s.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},s.p="",s(s.s=0)}([function(t,e,s){"use strict";s.r(e);var i,n,r,o={};s.r(o),s.d(o,"Vector2",function(){return c}),s.d(o,"Bound",function(){return g}),s.d(o,"Base",function(){return u}),s.d(o,"Line",function(){return f}),s.d(o,"Polyline",function(){return y}),s.d(o,"Polygon",function(){return m}),s.d(o,"Geometry_Type",function(){return l}),s.d(o,"Operation",function(){return a});class h{constructor(){this.events={}}hasEvent(t){return this.events[t]&&this.events[t].length>0}on(t,e,s){this.events[t]=this.events[t]||[],s===this&&(s=void 0);const i=t.split("|");for(const t of i)this.events[t].some(t=>t.fn===e&&t.ctx===s)||this.events[t].push({fn:e,ctx:s});return this}once(t,e,s){this.on(t,e,s);const i=()=>{this.off(t,e,s),this.off(t,i,s)};this.on(t,i,s)}fire(t,e){if(!this.events[t]||0===this.events[t].length)return;const s=Object.assign({},e,{type:t,target:this,sourceTarget:e&&e.sourceTarget||this});for(const e of this.events[t])e.fn.call(e.ctx,s)}off(t,e,s){if(e){s===this&&(s=void 0);const i=this.events[t];if(i){const t=i.findIndex(t=>t.fn===e&&t.ctx===s);t>-1&&i.splice(t,1)}}else delete this.events[t]}listens(t){const e=this.events[t];return!(!e||!e.length)}}!function(t){t.POINT="POINT",t.POLYLINE="POLYLINE",t.POLYGON="POLYGON",t.CIRCLE="CIRCLE",t.RECTANGLE="RECTANGLE",t.IMAGE="IMAGE",t.GROUP="GROUP",t.TEXT="TEXT",t.QUADRATICBERZIER="QUADRATICBERZIER"}(i||(i={})),function(t){t.LEFT="left",t.CENTER="center",t.RIGHT="right"}(n||(n={})),function(t){t.TOP="top",t.MIDDLE="middle",t.BOTTOM="bottom"}(r||(r={}));class a{static degreeToRadius(t){return Math.PI*t/180}static radiusToDegree(t){return t/Math.PI*180}static getDotMultiply(t,e){return t.x*e.x+t.y*e.y}static getCrossMultiply(t,e){return t.x*e.y-t.y*e.x}}class c{static lerp(t,e,s){const i=new c(e.x-t.x,e.y-e.y);return t.add(i.scale(s))}constructor(t,e){"number"==typeof t&&"number"==typeof e?(this.x=t,this.y=e):t instanceof Array&&t.length>1&&void 0===e?(this.x=t[0],this.y=t[1]):(t.hasOwnProperty("x")&&t.hasOwnProperty("y")||console.error("Vector constructor call a error."),this.x=t.x,this.y=t.y)}add(t){return this.x+=Number(t.x),this.y+=Number(t.y),this}substract(t){return this.x-=Number(t.x),this.y-=Number(t.y),this}normalize(){const t=this.getModelLength();return 0===t?new c(0,0):new c(this.x/t,this.y/t)}clone(){return new c(this.x,this.y)}rotate(t){const e=a.degreeToRadius(t),s=this.x*Math.cos(e)-this.y*Math.sin(e),i=this.x*Math.sin(e)+this.y*Math.cos(e);return this.x=s,this.y=i,this}scale(t,e){return this.x*=t,this.y*=e||t,this}getSquareLength(){return this.x**2+this.y**2}getModelLength(){return Math.sqrt(this.x**2+this.y**2)}toArray(){return[this.x,this.y]}}var l,d={Zero:1e-5,PI:Math.PI,PI2:2*Math.PI};class u{static isZero(t,e){return void 0!==e?Math.abs(t)<=Math.abs(e):Math.abs(t)<=d.Zero}static isSamePoint(t,e){const s=Array.isArray(t)?t:[t.x,t.y],i=Array.isArray(e)?e:[e.x,e.y];return this.isZero(s[0]-i[0])&&this.isZero(s[1]-i[1])}static getDistance(t,e){return Math.sqrt((t[0]-e[0])**2+(t[1]-e[1])**2)}static getSquareDistance(t,e){return(t[0]-e[0])**2+(t[1]-e[1])**2}static transformPointToArray(t){return Array.isArray(t)?t:[t.x,t.y]}static transformPointToXY(t){return Array.isArray(t)?{x:t[0],y:t[1]}:t}static transformPointsToArray(t){const e=[];for(const s of t)e.push(this.transformPointToArray(s));return e}static transformPointsToXY(t){const e=[];for(const s of t)e.push(this.transformPointToXY(s));return e}static getBoundOfPoints(t){const e=t.map(t=>t[0]),s=t.map(t=>t[1]),i=Math.min(...e),n=Math.max(...e),r=Math.min(...s),o=Math.max(...s);return new g(i,r,Math.abs(n-i),Math.abs(o-r))}static getDirectionVec(t,e){return new c(e[0]-t[0],e[1]-t[1])}static isLeftOfLine(t,e,s){let[i,n]=[new c(e),new c(s)];i.y>n.y&&([i,n]=[n,i]);const r=new c(n.x-i.x,n.y-i.y),o=new c(t[0]-i.x,t[1]-i.y);return a.getCrossMultiply(r,o)>0}static isBothSide(t,e,s){return a.getCrossMultiply(t,e)*a.getCrossMultiply(t,s)<0}}class g{static isOverlaped(t,e){return t.isOverlaped(e)}constructor(t,e,s=0,i=0){if(Array.isArray(t)&&Array.isArray(e)){const s=Math.min(t[0],e[0]),i=Math.min(t[1],e[1]),n=Math.max(t[0],e[0]),r=Math.max(t[1],e[1]);this.x=s,this.y=i,this.width=Math.abs(n-s),this.height=Math.abs(r-i)}else this.x=t,this.y=e,this.width=s,this.height=i}clone(){return new g(this.x,this.y,this.width,this.height)}getBound(){return{x:this.x,y:this.y,width:this.width,height:this.height}}getCenter(){return[this.x+this.width/2,this.y+this.height/2]}getNorthEast(){return[this.x+this.width,this.y+this.height]}getSouthWest(){return[this.x,this.y]}getVetexs(){return[[this.x,this.y],[this.x,this.y+this.height],[this.x+this.width,this.y+this.height],[this.x+this.width,this.y]]}isOverlaped(t){const e=this.getCenter(),s=t.getCenter();return Math.abs(s[0]-e[0])<(this.width+t.width)/2&&Math.abs(s[1]-e[1])<(this.height+t.height)/2}contain(t){if(t instanceof g){for(const e of t.getVetexs())if(!this.contain(e))return!1;return!0}return t[0]>this.x&&t[1]>this.y&&t[0]<this.x+this.width&&t[1]<this.y+this.height}union(t){const e=Math.min(this.x,t.x),s=Math.min(this.y,t.y),i=Math.max(this.x+this.width,t.x+t.width),n=Math.max(this.y+this.height,t.y+t.height);return this.x=e,this.y=s,this.width=i-e,this.height=n-s,this}expand(t,e){return this.width+=2*t,this.x-=t,void 0!==e?(this.y-=e,this.height+=2*e):(this.y-=t,this.height+=2*t),this}isIntersectOfSegment(t,e){if(u.getBoundOfPoints([t,e]).isOverlaped(this)){if(this.contain(t)||this.contain(e))return!0;{const s=u.getDirectionVec(t,e),i=this.getVetexs();for(let e=1;e<i.length;e++){const n=u.getDirectionVec(t,i[e-1]),r=u.getDirectionVec(t,i[e]);if(u.isBothSide(s,n,r))return!0}return!1}}return!1}}!function(t){t[t.VECTOR=0]="VECTOR",t[t.LINE=1]="LINE",t[t.BOX=2]="BOX"}(l||(l={}));class f{static getPedalPointOfLine(t,e,s){[t,e,s]=u.transformPointsToXY([t,e,s]);const i=new c(t.x-e.x,t.y-e.y),n=new c(s.x-e.x,s.y-e.y),r=a.getDotMultiply(i,n)/n.getModelLength();return new c(e.x,e.y).add(n.normalize().scale(r))}static getNearestPointToSegment(t,e,s){[t,e,s]=u.transformPointsToArray([t,e,s]);const i=this.getPedalPointOfLine(t,e,s);if(this.isPointAtSegment(i,e,s))return[i.x,i.y];return u.getSquareDistance(t,e)<u.getSquareDistance(t,s)?u.transformPointToArray(e):u.transformPointToArray(s)}static getDistanceToLine(t,e,s){[t,e,s]=u.transformPointsToArray([t,e,s]);const i=new c(t[0]-e[0],t[1]-e[1]),n=new c(s[0]-e[0],s[1]-e[1]),r=a.getCrossMultiply(i,n);return Math.abs(r/n.getModelLength())}static isPointAtLine(t,e,s,i){[t,e,s]=u.transformPointsToArray([t,e,s]);const n=new c(s[0]-e[0],s[1]-e[1]),r=new c(t[0]-e[0],t[1]-e[1]),o=a.getCrossMultiply(n,r);return u.isZero(o,i)}static isPointAtSegment(t,e,s,i){return[t,e,s]=u.transformPointsToArray([t,e,s]),(t[0]-e[0])*(t[0]-s[0])<=0&&(t[1]-e[1])*(t[1]-s[1])<=0&&this.isPointAtLine(t,e,s)}static isParalled(t,e,s,i,n){[t,e,s,i]=u.transformPointsToArray([t,e,s,i]);const r=new c(e[0]-t[0],e[1]-t[1]),o=new c(i[0]-s[0],i[1]-s[1]),h=a.getCrossMultiply(r,o);return u.isZero(h,n)}static isCollinear(t,e,s,i,n){[t,e,s,i]=u.transformPointsToArray([t,e,s,i]);const r=new c(e[0]-t[0],e[1]-t[1]),o=new c(i[0]-s[0],i[1]-s[1]),h=new c(t[0]-s[0],e[1]-s[1]),l=a.getCrossMultiply(r,o),d=a.getCrossMultiply(r,h);return u.isZero(l,n)&&u.isZero(d,n)}static isIntersect(t,e,s,i,n){return!this.isParalled(t,e,s,i,n)}static getIntersectPt(t,e,s,i){if(this.isParalled(t,e,s,i))return this.isCollinear(t,e,s,i)?void console.warn("These lines is collinear"):void console.warn("These lines is paralled");[t,e,s,i]=u.transformPointsToArray([t,e,s,i]);const n=new c(e[0]-t[0],e[1]-t[1]),r=new c(i[0]-s[0],i[1]-s[1]),o=new c(s[0]-t[0],s[1]-t[1]),h=new c(i[0]-t[0],i[1]-t[1]),l=Math.abs(a.getCrossMultiply(n,o)),d=Math.abs(a.getCrossMultiply(n,h));let g=0;return g=u.isBothSide(n,o,h)?l/(l+d):l/(l-d),new c(s[0],s[1]).clone().add(r.clone().scale(g))}static isIntersectOfSegment(t,e,s,i,n){[t,e,s,i]=u.transformPointsToArray([t,e,s,i]);const r=new c(e[0]-t[0],e[1]-t[1]),o=new c(i[0]-s[0],i[1]-s[1]),h=new c(s[0]-t[0],s[1]-t[1]),a=new c(i[0]-t[0],i[1]-t[1]),l=new c(t[0]-s[0],t[1]-s[1]),d=new c(e[0]-s[0],e[1]-s[1]);return u.isBothSide(r,h,a)&&u.isBothSide(o,l,d)}constructor(t,e){t=u.transformPointToArray(t),e=u.transformPointToArray(e),this.v0=new c(t[0],t[1]),this.v1=new c(e[0],e[1])}getDirVector(){const t=this.v1.x-this.v0.x,e=this.v1.y-this.v0.y;return new c(t,e)}getDirection(){return this.getDirVector().normalize()}getLineLength(){return this.getDirVector().getModelLength()}getBound(){const t=Math.min(this.v0.x,this.v1.x),e=Math.min(this.v0.y,this.v1.y),s=Math.abs(this.v1.x-this.v0.x),i=Math.abs(this.v1.y-this.v0.y);return new g(t,e,s,i)}isPointAtLine(t,e){t=u.transformPointToArray(t);const s=this.getDirVector(),i=new c(t[0]-this.v0.x,t[1]-this.v1.y),n=a.getCrossMultiply(s,i);return u.isZero(n,e)}isParalled(t,e){const s=this.getDirection(),i=t.getDirection(),n=a.getCrossMultiply(s,i);return u.isZero(n,e)}isCollinear(t,e){const s=t.getDirection(),i=new c(t.v0.x-this.v0.x,t.v0.y-this.v0.y),n=a.getCrossMultiply(s,i);return this.isParalled(t,e)&&u.isZero(n,e)}isIntersect(t,e){return!this.isParalled(t,e)}getIntersectPt(t){if(this.isParalled(t))return this.isCollinear(t)?void console.warn("These lines is collinear"):void console.warn("These lines is paralled");const e=this.getDirVector(),s=t.getDirVector(),i=new c(t.v0.x-this.v0.x,t.v0.y-this.v0.y),n=new c(t.v1.x-this.v0.x,t.v1.y-this.v0.y),r=Math.abs(a.getCrossMultiply(e,i)),o=Math.abs(a.getCrossMultiply(e,n));let h=0;return h=u.isBothSide(e,i,n)?r/(r+o):r/(r-o),t.v0.clone().add(s.clone().scale(h))}isIntersectOfSegment(t){const e=this.getDirVector(),s=t.getDirVector(),i=new c(t.v0.x-this.v0.x,t.v0.y-this.v0.y),n=new c(t.v1.x-this.v0.x,t.v1.y-this.v0.y),r=new c(this.v0.x-t.v0.x,this.v0.y-t.v0.y),o=new c(this.v1.x-t.v0.x,this.v1.y-t.v0.y);return u.isBothSide(e,i,n)&&u.isBothSide(s,r,o)}isIntersectOfBound(t){return t.isIntersectOfSegment(u.transformPointToArray(this.v0),u.transformPointToArray(this.v1))}}class y{constructor(t){this.coordinates=t}getBound(){let t=Number.MAX_VALUE,e=Number.MAX_VALUE,s=-Number.MAX_VALUE,i=-Number.MAX_VALUE;const n=this.coordinates.flat();if(Array.isArray(n[0]))for(const n of this.coordinates){const r=n;for(const n of r)t=Math.min(t,n[0]),e=Math.min(e,n[1]),s=Math.max(s,n[0]),i=Math.max(i,n[1])}else for(const n of this.coordinates){const r=n;t=Math.min(t,r[0]),e=Math.min(e,r[1]),s=Math.max(s,r[0]),i=Math.max(i,r[1])}return new g(t,e,s-t,i-e)}getNearestPoint(t){t=u.transformPointToArray(t);const e=[],s=this.coordinates.flat();if(Array.isArray(s[0]))for(const s of this.coordinates){const i=s;for(let s=0;s<i.length-1;s++){const n=f.getNearestPointToSegment(t,i[s],i[s+1]),r=u.getSquareDistance(t,n);e.push({dis:r,pos:n})}}else{const s=this.coordinates;for(let i=0;i<s.length-1;i++){const n=f.getNearestPointToSegment(t,s[i],s[i+1]),r=u.getSquareDistance(t,n);e.push({dis:r,pos:n})}}return e.sort((t,e)=>t.dis-e.dis),e[0].pos}transformToArray(t){return u.transformPointsToArray(t)}}class m extends y{constructor(t){super(t),this._cleanData()}isPointAtPolygon(t,e){let s=0;for(let i=0;i<e.length-1;++i){const n=e[i],r=e[i+1];this._isWithInTrapezoid(t,n,r)&&s++}return s%2==1}contain(t,e=2){if(t=u.transformPointToArray(t),!this.getBound().contain(t))return!1;const s=this.coordinates.flat();if(!Array.isArray(s[0]))return this.isPointAtPolygon(t,this.coordinates);for(const s of this.coordinates){const i=s;if(2===i.length){if(f.getDistanceToLine(t,i[0],i[1])<e)return!0}else if(this.isPointAtPolygon(t,i))return!0}return!1}_cleanData(){const t=this.coordinates.flat();if(Array.isArray(t[0]))for(const t of this.coordinates){const e=t;e.length>2&&!u.isSamePoint(e[0],e[e.length-1])&&e.push(t[0])}else{const t=this.coordinates;u.isSamePoint(t[0],t[t.length-1])||t.push(t[0])}}_isWithInTrapezoid(t,e,s){const i=Math.max(e[1],s[1]),n=Math.min(e[1],s[1]);return u.isLeftOfLine(t,e,s)&&t[1]>n&&t[1]<i}}class p{static createID(){return"xxxxxxxxxxxx-6xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,t=>{const e=16*Math.random()|0;return("x"===t?e:3&e|8).toString(16)})}static transformToXY(t){if(t.length<2)throw new Error("coordinate length less than two...");return{x:t[0],y:t[1]}}static transformToArray(t){return[t.x,t.y]}static transformToXYPath(t){const e=[];for(const s of t)e.push(this.transformToXY(s));return e}static transformToArrayPath(t){const e=[];for(const s of t)e.push(this.transformToArray(s));return e}static loadImageByBlob(t){const e=new XMLHttpRequest;return e.open("GET",t,!0),e.responseType="blob",e.send(),new Promise(t=>{e.onload=function(){t(this.response)}})}static downLoadByBase64String(t,e=`newFile${Date.now()}`){const s=t.split(";base64,"),i=s[0].split(":")[1],n=window.atob(s[1]),r=n.length,o=new Uint8Array(r);for(let t=0;t<r;++t)o[t]=n.charCodeAt(t);const h=new Blob([o],{type:i}),a=document.createElement("a");a.href=URL.createObjectURL(h),a.download=e,a.click()}static dimension_Array(t){return t instanceof Array?Math.max(...t.map(t=>1+p.dimension_Array(t))):0}}class x{constructor(t,e,s,i=1){this.retina=1,this.isCache=!1,this.w=0,this.h=0,this.center=[0,0],this.bgColor="#ffffff",this.render=s,this.retina=window.devicePixelRatio||1,this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.scale=i,this.aliaveCache=new Map,this.updateSize(t,e)}getCanvasDom(){return this.canvas}getScale(){return this.scale}getOriginCenter(){return this.center}getViewBound(){const t=this.screenToWorldCoordinate([0,this.h/this.retina]),e=this.screenToWorldCoordinate([this.w/this.retina,0]);return new g(t[0],t[1],e[0]-t[0],e[1]-t[1])}getDrawStatus(){return!0}localToWorldCoordinate(t){return[t[0]/this.retina,-t[1]/this.retina]}worldCoordinateToLocal(t){return[Math.round(t[0]*this.retina),Math.round(-t[1]*this.retina)]}worldCoordinateToScreen(t){return[this.center[0]/this.retina+t[0]*this.scale,this.center[1]/this.retina-t[1]*this.scale]}screenToWorldCoordinate(t){return[(t[0]-this.center[0]/this.retina)/this.scale,(this.center[1]/this.retina-t[1])/this.scale]}getOffset(t){return[(t.offsetX*this.retina-this.center[0])/this.scale,(this.center[1]-t.offsetY*this.retina)/this.scale]}getOffsetToScreenCenter(t){return[t[0]*this.retina-this.w/2,t[1]*this.retina-this.h/2]}getCenterPoint(){return this.screenToWorldCoordinate([this.w/2/this.retina,this.h/2/this.retina])}measureTextWidth(t){return t.options&&t.options.font&&(this.context.font=t.options.font),this.context.measureText(t.text).width}getCache(){return x.cache}transformScreenDistance(t){return t/this.scale/this.retina}setCache(t){x.cache=t}addCache(t,e){x.cache.set(t,e)}setRetina(t){this.retina=t}setBackground(t){this.context.clearRect(0,0,this.w,this.h),this.context.fillStyle=t||this.bgColor,this.context.fillRect(0,0,this.w,this.h)}setScale(t){this.scale=t}setCenter(t){this.center=t}updateSize(t,e){this.w=t*this.retina,this.h=e*this.retina,this.canvas.style.width=`${t}px`,this.canvas.style.height=`${e}px`,this.canvas.width=this.w,this.canvas.height=this.h,this.center=[this.w/2,this.h/2]}clear(){this.context.clearRect(0,0,this.w,this.h)}clearPart(t){const e=this.worldCoordinateToScreen([t.x,t.y+t.height]);this.context.clearRect(e[0]-1,e[1]-1,t.width*this.scale+1,t.height*this.scale+1)}startDraw(t){this.context.save(),this.context.translate(this.center[0],this.center[1]),this.context.scale(this.scale,this.scale),t&&this.aliaveCache.clear()}endDraw(t){this.context.restore()}drawCircle(t){const e=t.getGeometry(),s=t.getRadius();this.context.beginPath();const i=this.worldCoordinateToLocal(e);this.context.arc(i[0],i[1],s*this.retina,0,2*Math.PI),this._fillstroke(t)}drawPolyline(t){const e=t.getGeometry();if(0!==e.length)if(this.context.beginPath(),2===p.dimension_Array(e)){for(let t=0;t<e.length;t++){const s=this.worldCoordinateToLocal(e[t]);this.context[t?"lineTo":"moveTo"](s[0],s[1])}t.getLayerType()===i.POLYGON&&this.context.closePath(),this._fillstroke(t)}else for(const s of e){this.context.beginPath();for(let t=0;t<s.length;t++){const e=this.worldCoordinateToLocal(s[t]);this.context[t?"lineTo":"moveTo"](e[0],e[1])}t.getLayerType()===i.POLYGON&&this.context.closePath(),this._fillstroke(t)}}drawQuadraticBerzier(t){const e=t.getGeometry().map(t=>this.worldCoordinateToLocal(t));this.context.beginPath(),this.context.moveTo(e[0][0],e[0][1]),this.context.quadraticCurveTo(e[1][0],e[1][1],e[2][0],e[2][1]),this._fillstroke(t)}drawRectangle(t){this.context.beginPath();const e=this.worldCoordinateToLocal(t.getNorthWest());this.context.rect(e[0],e[1],t.width*this.retina,t.height*this.retina),this._fillstroke(t)}async drawImage(t){if(t.accesible)if(x.cache.has(t.url)){this.render.deletePeddingLayer(t);const e=x.cache.get(t.url);this.aliaveCache.set(t.url,e);const s=t.getGeometry(),i=this.worldCoordinateToLocal([s.x,s.y+s.height]);this.isCache&&(this.context.shadowOffsetX=5,this.context.shadowOffsetY=5,this.context.shadowBlur=8,this.context.shadowColor="rgba(0, 0, 0, 0.5)"),this.context.drawImage(e,i[0],i[1],s.width*this.retina,s.height*this.retina)}else{console.log(!1,t.url),this.render.setPeddingLayer(t.id);const e=await t.loadImageData();x.cache.set(t.url,e),this.render.redraw()}}drawText(t){this.context.save(),this._setFontStyle(t);const e=t.getGeometry(),s=this.worldCoordinateToLocal(e),i=t.content.map(t=>t.text),n=t.getFontSize(),r=t.options.verticleSpace*this.retina,o=t.content.length;for(let e=0;e<o;e++){let h=0;1===e&&(this.context.textAlign="left",s[0]-=t.options.maxLength/2*this.retina),h="bottom"===t.options.baseLine?s[1]-(o-e-1)*(n+r):"middle"===t.options.baseLine?s[1]-((o-1)/2-e)*(n+r):s[1]+(n+r)*e,t.options.fill?this.context.fillText(i[e],s[0],h):t.options.stroke&&this.context.strokeText(i[e],s[0],h)}this.context.restore()}getTextWidth(t,e){this.context.save(),e&&(this.context.font=e);const s=this.context.measureText(t).width;return this.context.restore(),s}_fillstroke(t){const e=this.isCache?{...t.options,...t.highOptions}:t.options;e.fill&&(this.context.globalAlpha=e.fillOpacity,this.context.fillStyle=e.fillColor||e.color,this.context.fill(e.fillRule||"evenodd")),e.shadow&&(this.context.shadowOffsetX=e.shadowOffsetX||5,this.context.shadowOffsetY=e.shadowOffsetY||-5,this.context.shadowBlur=e.shadowBlur||12,this.context.shadowColor=e.shadowColor||"rgba(0, 0, 0, 0.5)"),e.stroke&&0!==e.weight&&(this.context.setLineDash&&this.context.setLineDash(t.options&&t.options.dashArray||[]),this.context.globalAlpha=e.opacity,this.context.lineWidth=e.weight*this.retina,this.context.strokeStyle=e.color,this.context.lineCap=e.lineCap,this.context.lineJoin=e.lineJoin,this.context.stroke())}_setFontStyle(t){const e=this.isCache?{...t.options,...t.highOptions}:t.options;e.font&&(this.context.font=e.font.replace(/\d+px/,t=>+t.slice(0,t.length-2)*this.retina+"px")),e.fill&&(this.context.fillStyle=this.isCache?t.highOptions.fillColor||t.highOptions.color:t.options.fillColor||t.options.color),e.shadow&&(this.context.shadowOffsetX=e.shadowOffsetX||5,this.context.shadowOffsetY=e.shadowOffsetY||-5,this.context.shadowBlur=e.shadowBlur||12,this.context.shadowColor=e.shadowColor||"rgba(0, 0, 0, 0.5)"),e.stroke&&(this.context.strokeStyle=this.isCache?t.highOptions.color:t.options.color),this.context.textAlign=e.textAlign,this.context.textBaseline=e.baseLine}}x.cache=new Map;class w extends h{constructor(){super(),this.userCache=!0,this.highOptions={fill:!0,fillColor:"#0FFFFF",color:"#0FFFFF"},this.tolerance=5,this.id=p.createID(),this.options={stroke:!0,color:"#3388ff",weight:1,opacity:1,lineCap:"butt",lineJoin:"miter",dashArray:null,dashOffset:null,fill:!1,fillColor:null,fillOpacity:1,fillRule:"evenodd",shadow:!1,strict:!0},this.type=this.getLayerType()}getStage(){return this.options._stage}getDirtyData(){return this.dirtyData}setOptions(t){Object.keys(t).forEach(e=>{this.options[e]=t[e]})}setStyle(t){this.setOptions(t),this.updateAll()}setDirtyData(t){this.dirtyData=t}highLight(t={}){this.setHighlightOptions(t),this.getStage().addHighLightLayer(this)}setHighlightOptions(t={}){this.highOptions={...this.highOptions,...t}}clearHighLight(){this.getStage().clearHighLightLayer(this)}addTo(t){return t.addLayer(this),this}layerAdd(t){this.setRender(t),this.options._render.addDraw(this),this.fire("loaded",{layer:this,sourceTarget:t.container}),t.fire("layerAdd",{layer:this})}clearnData(t){const e=[];for(const s of t)e.push(this.transformVertex(s));return e}transformVertex(t){return Array.isArray(t)?t:this.transformToArray(t)}transformToArray(t){return[t.x,t.y]}updateAll(){this.options._render&&this.options._render.redraw()}addPath(){this.options._render&&this.options._render.addDraw(this)}remove(){this.options._stage&&this.options._stage.removeLayer(this)}removePath(){const t=this.getBound();this.options._render.clearBoundPath(t)}getBound(){const t=this.getGeometry();if(t instanceof g)return t;const e=p.dimension_Array(t);if(2===e){return new y(t).getBound()}if(3===e){let e=null;for(const s of t){const t=new y(s);e=e?t.getBound().union(e):t.getBound()}return e}return new g(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)}getCenter(){return this.getBound().getCenter()}containPoint(t){return this.getBound().contain(t)}setRender(t){this.options._stage=t,this.options._render=t.render}isIntersectWithBound(t){return!1}isWithinBound(t){return t.contain(this.getBound())}}class v extends w{constructor(t,e,s={}){super(),this.content=[],this.geometry=t,this.text=e;const i={fill:!0,stroke:!1,font:"14px Arial",textAlign:n.LEFT,baseLine:r.MIDDLE,maxLength:0,verticleSpace:0};this.setOptions({...i,...s}),s.fontSize&&"number"==typeof s.fontSize&&(this.options.font=s.fontSize.toString()+"px Arial")}getLayerType(){return i.TEXT}getGeometry(){return this.geometry}getBound(){const t=this.getFontSize(),e=this.content.length,s=t*e+(e-1)*this.options.verticleSpace;let i=this.options.maxLength;1===e&&(i=this.content[0].width);let[n,r]=[this.geometry[0],this.geometry[1]];return"end"===this.options.textAlign||"right"===this.options.textAlign?n-=i:"center"===this.options.textAlign&&(n-=i/2),"top"===this.options.baseLine||"hanging"===this.options.baseLine?r-=s:"middle"===this.options.baseLine&&(r-=s/2),new g(n,r,i,s)}computeOutline(){const t=this.getFontSize()+this.options.verticleSpace,e=this.getBound().getVetexs();if(this.content.length>1){const s=e[0],i=e[e.length-1],n=this.content[this.content.length-1];if("end"===this.options.textAlign||"right"===this.options.textAlign)e.splice(0,1,[e[0][0],e[0][1]+t]),e.push([i[0]-n.width,i[1]],[i[0]-n.width,i[1]+t]);else if("center"===this.options.textAlign){const s=(this.options.maxLength-n.width)/2;e.splice(0,1,[e[0][0],e[0][1]+t]);const r=[[i[0],i[1]+t],[i[0]-s,i[1]+t],[i[0]-s,i[1]],[i[0]-s-n.width,i[1]],[i[0]-s-n.width,i[1]+t]];e.splice(-1,1,...r)}else{const r=[[i[0],i[1]+t],[s[0]+n.width,s[1]+t],[s[0]+n.width,s[1]]];e.splice(-1,1,...r)}}return e}setText(t){this.text=t,this.fixContent(),this.updateAll()}translate(t,e){this.geometry[0]+=t,this.geometry[1]+=e,this.updateAll()}isPointClosest(t){const e=this.computeOutline();e.push(e[0]);let s=0;for(let i=0;i<e.length-1;i++){const n=e[i],r=e[i+1];u.isZero(n[0]-r[0])&&t[0]<n[0]&&(t[1]-n[1])*(t[1]-r[1])<0&&s++}return s%2==1}fixContent(){if(this.text)if(this.options.maxLength&&this.options.maxLength>0){const t=this.text.split(""),e=[t[0]];for(let s=1;s<t.length;s++){const i=e.join(""),n=this.options._render.canvasHelper.getTextWidth(i+t[s],this.options.font);n>this.options.maxLength?(this.content.push({text:i,width:n}),e.length=0):s===t.length-1&&this.content.push({text:i+t[s],width:n}),e.push(t[s])}}else{const t=this.options._render.canvasHelper.getTextWidth(this.text,this.options.font);this.content.push({text:this.text,width:t})}}getFontSize(){const t=this.options.font.match(/\d+px/);return t.length>0?parseInt(t[0],10):10}isIntersectWithBound(t){const e=this.computeOutline();for(let s=0;s<e.length-1;s++)if(t.isIntersectOfSegment(e[s],e[s+1]))return!0;return!1}clone(){const t={...this.options,_render:null,_stage:null};return new v(this.geometry,this.text,t)}}class C{constructor(t,e,s){this.renderAll=!1,this.isBatching=!1;const i=s.getZoom();this.canvasHelper=new x(t,e,this,i),this.cacheHelper=new x(t,e,this,i),this.cacheHelper.isCache=!0,this.stage=s,this.peddingLayers=new Set}resize(t,e){this.canvasHelper.updateSize(t,e),this.cacheHelper.updateSize(t,e),this.redraw()}getCenter(){return this.canvasHelper.getCenterPoint()}getPos(t){return this.canvasHelper.screenToWorldCoordinate(t)}getCanvasDom(){const t=this.canvasHelper.getCanvasDom();return t.style.zIndex="0",t.style.position="absolute",t.style.top="0",t.style.left="0",t}getCacheCanvasDom(){const t=this.cacheHelper.getCanvasDom();return t.style.zIndex="1",t.style.position="absolute",t.style.top="0",t.style.left="0",t}getCanvasHelper(){return this.canvasHelper}getCacheHelper(){return this.cacheHelper}getBound(){return this.canvasHelper.getViewBound()}addCache(t,e){this.canvasHelper.addCache(t,e)}setBatch(t){this.isBatching=t}cloneCanvas(t){const e=[];if(this.stage.eachLayer(t=>{const s=t.getBound();e[0]=1===e.length?e[0].union(s):s}),0===e.length)return Promise.resolve(this.getCanvasDom());const s=e[0];let i=0,n=0,r=0,o=0,h=2;t&&(i=t.padding.left||0,n=t.padding.top||0,r=t.padding.right||0,o=t.padding.bottom||0,h=t.retina||2);const a=s.width+i+r,c=s.height+n+o,l=this.canvasHelper.getCache(),d=new C(a*h,c*h,this.stage);d._setRederAll(!0),d.canvasHelper.setRetina(h),d.canvasHelper.setCache(l);const u=[s.width/2+s.x-(i-r)/2,s.height/2+s.y-(o-n)/2];d.setCenter(u,1),d.canvasHelper.startDraw();const g=this.stage.getLayers();for(const t of g)d.drawPath(t);return new Promise(t=>{const e=()=>{0===d.peddingLayers.size?t(d.getCanvasDom()):requestAnimationFrame(e)};requestAnimationFrame(e)})}drawPath(t,e=this.canvasHelper){switch(t.getLayerType()){case i.CIRCLE:case i.POINT:e.drawCircle(t);break;case i.POLYLINE:case i.POLYGON:e.drawPolyline(t);break;case i.RECTANGLE:e.drawRectangle(t);break;case i.IMAGE:e.drawImage(t);break;case i.TEXT:e.drawText(t);break;case i.QUADRATICBERZIER:e.drawQuadraticBerzier(t);break;case i.GROUP:this.drawGroup(t,e)}}drawGroup(t,e){const s=t.getLayers();t.setSubRender(t.options._stage);for(const t of s){t.getLayerType()===i.GROUP?this.drawGroup(t,e):this.drawPath(t,e)}}renderCacheCanvas(){this.cacheHelper.clear();const t=this.stage.getHighLightLayers();if(0===t.length)return;this.cacheHelper.startDraw();const e=this.stage.getBound();for(const s of t){const t=s.getBound();t&&e.isOverlaped(t)&&this.drawPath(s,this.cacheHelper)}this.cacheHelper.endDraw()}addDraw(t){t instanceof v&&t.fixContent(),this.canvasHelper.startDraw(),this.drawPath(t),this.canvasHelper.endDraw()}redraw(){if(this.isBatching)return;this.canvasHelper.clear(),this.canvasHelper.startDraw(!0);const t=this.stage.getBound(),e=this.stage.getLayers();for(const s of e){if(this.renderAll){this.drawPath(s);continue}const e=s.getBound();e&&t.isOverlaped(e)&&this.drawPath(s)}this.canvasHelper.endDraw(!0),this.renderCacheCanvas()}setZoom(t){this.canvasHelper.setScale(t),this.updateCacheCanvas()}setCenter(t,e){this.canvasHelper.setScale(e);const s=this.canvasHelper.worldCoordinateToScreen(t),i=this.canvasHelper.getOffsetToScreenCenter(s),n=this.canvasHelper.getOriginCenter();this.canvasHelper.setCenter([n[0]-i[0],n[1]-i[1]]),this.updateCacheCanvas()}updateCacheCanvas(){const t=this.canvasHelper.getOriginCenter(),e=this.canvasHelper.getScale();this.cacheHelper.setCenter(t),this.cacheHelper.setScale(e)}clearBoundPath(t){this.canvasHelper.clearPart(t)}deletePeddingLayer(t){this.peddingLayers.has(t.id)&&this.peddingLayers.delete(t.id)}setPeddingLayer(t){this.peddingLayers.add(t)}_setRederAll(t){this.renderAll=t}}class L extends h{constructor(t,e={}){if(super(),this.draggEnable=!0,this.zoom=1,this.minZoom=.1,this.maxZoom=30,this.zoomChange=.1,this.container=document.getElementById(t),!this.container)throw new Error("Stage container is not found.");this.render=new C(this.container.clientWidth,this.container.clientHeight,this),this.layers=new Map,this.highLightLayers=new Map,this._initContainer(),this.center=this.render.getCenter(),this.options=e,this.options.id=t,this._setOptions(e),this._initEvents(),this._resize()}getLayers(t){const e=Array.from(this.layers.values());return t?e.filter(e=>t(e)):e}getLayer(t){const e=Array.from(this.layers.values());for(const s of e)if(t(s))return s}getHighLightLayers(){return Array.from(this.highLightLayers.values())}getZoom(){return this.zoom}getCenter(){return this.render.getCenter()}getMinzoom(){return this.minZoom}getMaxZoom(){return this.maxZoom}getBound(){return this.render.getBound()}transferWorldCoordinateToScreen(t){return this.render.getCanvasHelper().worldCoordinateToScreen(t)}async getAllLayerImage(t){return(await this.render.cloneCanvas(t)).toDataURL("image/png",.9)}getViewImage(){return this.render.getCanvasDom().toDataURL("image/png",.9)}getLayersByPosition(t){const e=[];for(const[s,i]of this.layers)i.isPointClosest(t)&&e.push(i);return e}getLayerByPosition(t,e){for(const[s,i]of this.layers)if(i.isPointClosest(t,e))return i}getLayersByBound(t,e=!0){const s=[];for(const[i,n]of this.layers)e&&n.isIntersectWithBound(t)?s.push(n):n.isWithinBound(t)&&s.push(n);return s}getScreenDistance(t){return this.render.getCanvasHelper().transformScreenDistance(t)}addLayer(t){const e=t.id;return this.layers.has(e)?this:(this.layers.set(e,t),t.layerAdd(this),this)}hasLayer(t){return!!t&&this.layers.has(t.id)}removeLayer(t){if(t&&!this.layers.has(t.id))return this;this.layers.delete(t.id),this.render.redraw(),this.fire("removed",{layer:t})}removeLayers(t){for(const e of t)this.layers.delete(e.id),this.highLightLayers.delete(e.id);this.render.redraw();for(const e of t)e.fire("removed",{layer:e})}clearAllLayers(){this.layers.clear(),this.render.redraw()}clearHighLightLayer(t){t?(this.highLightLayers.delete(t.id),this.highLightLayers.delete(t.id)):this.highLightLayers.clear(),this.render.renderCacheCanvas()}addHighLightLayer(t){this.highLightLayers.set(t.id,t)}hilightLayers(){this.render.renderCacheCanvas()}eachLayer(t){const e=Array.from(this.layers);for(const s of this.layers)t&&t(s[1],s[0],e)}clearAllEvents(){this.events={}}setZoom(t){const e=this._getValidateZoom(t);e&&this.setView(this.center,e)}zoomIn(){this.setZoom(this.zoom+this.zoomChange)}zoomOut(){this.setZoom(this.zoom-this.zoomChange)}addImagesCache(t){for(const e of t){const t=new Image;t.src=e,t.addEventListener("load",()=>{this.render.addCache(e,t)})}}setView(t,e){this._render(t,e||this.zoom)}fitBound(t){const e=t.getCenter(),{width:s,height:i}=this.getBound();let n=s*this.zoom/t.width,r=i*this.zoom/t.height;n=Math.floor(n/this.zoomChange)*this.zoomChange,r=Math.floor(r/this.zoomChange)*this.zoomChange;const o=Math.min(n,r);let h=Math.max(o,this.minZoom);h=Math.min(h,1),this._render(e,h)}forceRender(t){this.render.setCenter(t||this.center,this.zoom),this.render.redraw()}enableDrag(){this.draggEnable=!0}disableDrag(){this.draggEnable=!1}updateSize(){this.render.resize(this.container.clientWidth,this.container.clientHeight)}startBatch(){this.render.setBatch(!0)}endBatch(){this.render.setBatch(!1),this.render.redraw()}_render(t,e){const s=(t[0]-this.center[0])/16,i=(t[1]-this.center[1])/16,n=(e-this.zoom)/16;this.amination&&cancelAnimationFrame(this.amination),this._amination(s,i,n,()=>u.isSamePoint(this.getCenter(),t)&&u.isZero(this.zoom-e))}_amination(t,e,s,i){i()?this.fire("moveend",{target:this,sourceTarget:event}):(this.center[0]+=t,this.center[1]+=e,this.zoom+=s,this.amination=requestAnimationFrame(()=>{this.render.setCenter(this.center,this.zoom),this.render.redraw(),this._amination(t,e,s,i)}))}_setOptions(t){t&&(this.zoom=t.zoom||this.zoom,this.minZoom=t.minZoom||this.minZoom,this.maxZoom=t.maxZoom||this.maxZoom,this.zoomChange=t.zoomChange||this.zoomChange)}_getValidateZoom(t){if(!isNaN(t))return t=Number(t),t=Math.max(this.minZoom,t),t=Math.min(t,this.maxZoom);console.warn("stage zoom can't be NaN")}_resize(){window.addEventListener("resize",()=>{this.updateSize()})}_initContainer(){this.container.appendChild(this.render.getCanvasDom()),this.container.appendChild(this.render.getCacheCanvasDom())}_initEvents(){const t=this._eventHandler,e=["click","dblclick","mousedown","mousemove","mouseup","mouseover","mouseleave","mousewheel","contextmenu"];for(const s of e)this._listenerEvent(s,t);const s=this.render.getCacheCanvasDom();s.addEventListener("mousedown",this._pan.bind(this)),s.addEventListener("touchstart",this._pan.bind(this)),document.addEventListener("selectstart",()=>!1)}_zoom(){const t=this.render.getCanvasHelper(),e=event,s=e.wheelDelta?e.wheelDelta/120*this.zoomChange:-e.detail*this.zoomChange;if(s<0&&this.zoom+s<this.minZoom||s>0&&this.zoom+s>this.maxZoom)return;this.zoom+=s;const i=t.getOffset(e);t.setScale(this.zoom);const n=t.getOriginCenter();t.setCenter([n[0]-i[0]*s,n[1]+i[1]*s]),this.render.updateCacheCanvas(),this.render.redraw(),this.fire("moveend",{target:this,sourceTarget:event}),e.preventDefault()}_pan(){if(!this.draggEnable)return;const t=this.render.getCanvasHelper(),e=event;let s=[e.clientX,e.clientY];e.touches&&(s=[e.touches[0].clientX,e.touches[0].clientY]);const i=()=>{let e=event;e.touches&&(e=e.touches[0]);const i=[e.clientX,e.clientY],n=(i[0]-s[0])*t.retina,r=(i[1]-s[1])*t.retina;s=i;const o=t.getOriginCenter();t.setCenter([o[0]+n,o[1]+r]),this.render.updateCacheCanvas(),this.render.redraw(),e.preventDefault()},n=()=>{document.removeEventListener("mousemove",i),document.removeEventListener("mouseup",n),document.removeEventListener("touchmove",i),document.removeEventListener("touchend",n);const t=event;this.center=this.getCenter(),this.fire("moveend",{target:this,sourceTarget:t}),t.preventDefault()};document.addEventListener(this._formatDOMEvent("mousemove"),i),document.addEventListener(this._formatDOMEvent("mouseup"),n),document.addEventListener("touchmove",i),document.addEventListener("touchend",n)}_listenerEvent(t,e){const s=this._validEventType(t);if(s){this.render.getCacheCanvasDom().addEventListener(s,e.bind(this))}}_eventHandler(){const t=event,e=t.type,s={target:this,sourceTarget:t};"contextmenu"===t.type&&t.preventDefault(),"keypress"!==t.type&&(s.pos=this.render.getPos([t.offsetX,t.offsetY])),e.split("|").forEach(t=>{this._fireEvent(t,s)})}_fireEvent(t,e){const s=this._findEventTargets(t,e.pos);for(const i of s)e.layer=i,i.fire(t,e)}_findEventTargets(t,e){const s=[];for(const[n,r]of this.layers)if(r.type===i.GROUP)for(const i of r.getLayers())i.listens(t)&&e&&i.isPointClosest(e)&&(s.push(i),s.includes(r)&&s.push(r));else r.listens(t)&&e&&r.isPointClosest(e)&&s.push(r);return this.listens(t)&&s.push(this),s}_formatDOMEvent(t){return navigator.userAgent.includes("Firefox")&&"mousewheel"===t?"DOMMouseScroll":t}_validEventType(t){return{click:"click",dblclick:"dblclick",mousedown:"mousedown",mousemove:"mousemove",mouseup:"mouseup",mouseover:"mouseover",mouseleave:"mouseleave",mousewheel:"mousewheel",contextmenu:"contextmenu"}[t=t.toLowerCase()]||""}}class A extends w{constructor(t,e,s){super(),this.radius=0,this.setOptions(s),this.highOptions.fill=this.options.fill,this.geometry=t,this.radius=e}getLayerType(){return i.CIRCLE}getGeometry(){return this.geometry}getCenter(){return this.geometry}getRadius(){return this.radius}getBound(){return new g(this.geometry[0]-this.radius,this.geometry[1]-this.radius,2*this.radius,2*this.radius)}setGeometry(t){this.geometry=t,this.updateAll()}setRadius(t){this.radius=t,this.updateAll()}contain(t){return u.getDistance(t,this.geometry)<this.radius}translate(t,e){const s=[this.geometry[0]+t,this.geometry[1]+e];this.setGeometry(s)}isPointClosest(t,e){if(this.options.fill||!this.options.strict)return u.getSquareDistance(t,this.geometry)<=this.radius**2;{const s=u.getDistance(t,this.geometry),i=void 0!==e?e:this.tolerance;return u.isZero(s-this.radius,i)}}getNearestPoint(t){const e=new c(this.geometry),s=new c(t),i=new c(s.x-e.x,s.y-e.y).normalize(),n=e.clone().add(i.scale(this.radius));return[n.x,n.y]}isIntersectWithBound(t){const e=new c(this.getCenter()),s=new c(t.getCenter()),i=e.clone().substract(s);i.x=Math.abs(i.x),i.y=Math.abs(i.y);const n=new c(t.width/2,t.height/2),r=i.clone().substract(n);r.x=Math.max(r.x,0),r.y=Math.max(r.y,0);const o=r.getSquareLength();let h=!1;for(const e of t.getVetexs())this.contain(e)||(h=!0);return o<=this.radius**2&&(!(!this.options.fill||this.options.strict)||h)}clone(){const t={...this.options,_render:null,_stage:null};return new A([this.geometry[0],this.geometry[1]],this.radius,t)}}class P extends w{constructor(t,e={}){super();this.setOptions({stroke:!0,weight:1,...e}),this.highOptions.fill=!1,this.geometry=this.clearnData(t)}clone(){const t={...this.options};return delete t._stage,delete t._render,new P(this.geometry,t)}getLayerType(){return i.POLYLINE}getGeometry(){return this.geometry}setGeometry(t){this.geometry=t,this.updateAll()}addVertex(t){const e=this.getGeometry();this.isMutiLine()||(e.push(t),this.updateAll())}translate(t,e){if(this.isMutiLine()){const s=this.geometry.map(s=>s.map(s=>[s[0]+t,s[1]+e]));this.setGeometry(s)}else{const s=this.geometry.map(s=>[s[0]+t,s[1]+e]);this.setGeometry(s)}}isMutiLine(){return 3===p.dimension_Array(this.geometry)}setLastVertex(t){const e=this.getGeometry();this.isMutiLine()||(e.splice(-1,1,t),this.updateAll())}getMinDistance(t){let e=Number.MAX_SAFE_INTEGER;const s=this.getGeometry();if(this.isMutiLine())for(const i of s){const s=new y(i).getNearestPoint(t),n=u.getDistance(t,s);e=Math.min(e,n)}else{const i=new y(s).getNearestPoint(t);e=u.getDistance(t,i)}return e}getNearestPoint(t){let e=Number.MAX_SAFE_INTEGER;const s=this.getGeometry();if(this.isMutiLine()){let i=[0,0];for(const n of s){const s=new y(n).getNearestPoint(t),r=u.getDistance(t,s);r<e&&(i=s,e=r)}return i}return new y(s).getNearestPoint(t)}isPointClosest(t,e){const s=this.getMinDistance(t);return void 0!==e?s<=e:s<=this.tolerance}isIntersectWithBound(t){const e=this.getGeometry();if(this.isMutiLine()){for(const s of e)for(let e=0;e<s.length-1;e++)if(t.isIntersectOfSegment(s[e],s[e+1]))return!0}else for(let s=0;s<e.length-1;s++)if(t.isIntersectOfSegment(e[s],e[s+1]))return!0;return!1}}class T extends P{constructor(t,e={}){super(t,{fill:!0,stroke:!0,weight:1,...e}),this.highOptions.fill=void 0===this.options.fill||this.options.fill}getLayerType(){return i.POLYGON}isPointClosest(t,e=0){const s=this.getGeometry();if(this.options.fill||!this.options.strict){return new m(s).contain(t,e)}return this.getMinDistance(t)<=this.tolerance}}class M extends w{constructor(t,e,s,i){if(super(),this.width=0,this.height=0,this.southWest=[],"number"==typeof arguments[1]&&"number"==typeof arguments[2]){const t=arguments[0].slice(),e=arguments[1],s=arguments[2];e<0&&(t[0]+=t[0]),s<0&&(t[1]+=t[1]),this.southWest=[t[0],t[1]],this.width=Math.abs(e),this.height=Math.abs(s)}else{if(!Array.isArray(arguments[0])||!Array.isArray(arguments[1]))throw TypeError("Rectangle constructor arguments in invalid");this.southWest=[Math.min(arguments[0][0],arguments[1][0]),Math.min(arguments[0][1],arguments[1][1])],this.width=Math.abs(arguments[0][0]-arguments[1][0]),this.height=Math.abs(arguments[0][1]-arguments[1][1])}let n={};"[object Object]"===Object.prototype.toString.call(arguments[arguments.length-1])&&(n={...arguments[arguments.length-1]});this.setOptions({fill:!0,stroke:!0,weight:1,...n}),this.highOptions.fill=this.options.fill}getGeometry(){return new g(this.southWest[0],this.southWest[1],this.width,this.height)}getLayerType(){return i.RECTANGLE}getNorthWest(){return[this.southWest[0],this.southWest[1]+this.height]}getSouthWest(){return this.southWest}translate(t,e){this.southWest[0]+=t,this.southWest[1]+=e,this.updateAll()}setBound(t){this.southWest=[t.x,t.y],this.width=t.width,this.height=t.height,this.updateAll()}setCorner(t,e){this.southWest=[Math.min(t[0],e[0]),Math.min(t[1],e[1])],this.width=Math.abs(t[0]-e[0]),this.height=Math.abs(t[1]-e[1]),this.updateAll()}isPointClosest(t){const e=this.getGeometry();if(this.options.fill||!this.options.strict)return e.contain(t);{const s=new y(e.getVetexs()).getNearestPoint(t);return u.getDistance(t,s)<=this.tolerance}}getNearestPoint(t){const e=this.getBound().getVetexs();return e.push(e[0]),new y(e).getNearestPoint(t)}isIntersectWithBound(t){return t.isOverlaped(this.getBound())}clone(){const t={...this.options,_render:null,_stage:null};return new M([this.southWest[0],this.southWest[1]],this.width,this.height,t)}}class b extends w{constructor(t,e,s,i,n,r={}){super(),this.accesible=!0,this.url=t,this.x=e,this.y=s,this.width=i||-1,this.height=n||-1,this.setOptions(r)}getLayerType(){return i.IMAGE}getGeometry(){return new g(this.x-this.width/2,this.y-this.height/2,this.width,this.height)}setImage(t,e,s){this.url=t,e&&(this.width=e),s&&(this.height=s),this.updateAll()}async loadImageData(){const t=new Image;t.src=this.url;const e=this;return new Promise((s,i)=>{t.addEventListener("load",()=>{e._setImage(t),s(t)}),t.addEventListener("error",()=>{e.accesible=!1,i("image is not found")})})}translate(t,e){this.x+=t,this.y+=e,this.updateAll()}isPointClosest(t){if("baseLayer"===this.options.type)return!1;return this.getBound().contain(t)}isWithinBound(t){if("baseLayer"===this.options.type)return!1;{const e=this.getBound();return t.isOverlaped(e)}}isIntersectWithBound(t){if("baseLayer"===this.options.type)return!1;return this.getBound().isOverlaped(t)}clone(){return new b(this.url,this.x,this.y,this.width,this.height,{...this.options})}_setImage(t){-1!==this.width&&-1!==this.height||(this.width=t.width,this.height=t.height)}}class O extends w{constructor(t,e={}){super(),this.layers=new Map;this.setOptions({strict:!0,...e});for(const e of t)this.layers.set(e.id,e)}getLayerType(){return i.GROUP}getGeometry(){if(0===this.layers.size)return;const t=[];for(const[e,s]of this.layers){const e=s.getBound();t[0]=t.length>0?t[0].union(e):e}return t[0]}getLayers(){return Array.from(this.layers.values())}getLayer(t){for(const e of this.getLayers())if(t(e))return e}eachLayer(t){const e=this.getLayers();for(let s=0;s<e.length;s++)t&&t(e[s],s,e)}setSubRender(t){const e=this.getLayers();for(const s of e)s.options._stage&&s.options._stage===t||(s.options._stage=t,s.options._render=t.render,s instanceof v&&s.fixContent())}addLayer(t){this.layers.set(t.id,t),this.updateAll()}removeLayer(t){this.layers.delete(t.id),this.updateAll()}translate(t,e){this.eachLayer(s=>{s.translate(t,e)})}isPointClosest(t,e){for(const[e,s]of this.layers)if(s.isPointClosest(t))return!0;return!1}isIntersectWithBound(t){for(const[e,s]of this.layers)if(s.isIntersectWithBound(t))return!0;return!1}highLight(){this.options._stage.addHighLightLayer(this)}clone(){const t={...this.options,_render:null,_stage:null},e=new O([],t);return this.eachLayer(t=>{e.addLayer(t.clone())}),e}}s.d(e,"Stage",function(){return L}),s.d(e,"Layer",function(){return w}),s.d(e,"Circle",function(){return A}),s.d(e,"Polyline",function(){return P}),s.d(e,"Polygon",function(){return T}),s.d(e,"Rectangle",function(){return M}),s.d(e,"ImageLayer",function(){return b}),s.d(e,"LayerGroup",function(){return O}),s.d(e,"IText",function(){return v}),s.d(e,"Math",function(){return o}),s.d(e,"Util",function(){return p})}])});